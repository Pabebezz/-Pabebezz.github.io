<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="Pabebe's Blog" type="application/atom+xml">






<meta name="description" content="OC特点OC没有命名空间，对象的成员变量是默认受保护的。 弱类型语言，单继承 init系统自带的初始化方法，默认是给基本数据类型赋值0，0.0，指针赋值NULL，对象指针类型赋值nil  本质上都是(void *)0 [CLASS  new] [[CLASS alloc]]init] [类型/对象 方法]">
<meta name="keywords" content="Pabebe&#39;s Blog">
<meta property="og:type" content="article">
<meta property="og:title" content="Objective-C语法点">
<meta property="og:url" content="https://pabebezz.github.io/article/d97699bf/index.html">
<meta property="og:site_name" content="Pabebe&#39;s Blog">
<meta property="og:description" content="OC特点OC没有命名空间，对象的成员变量是默认受保护的。 弱类型语言，单继承 init系统自带的初始化方法，默认是给基本数据类型赋值0，0.0，指针赋值NULL，对象指针类型赋值nil  本质上都是(void *)0 [CLASS  new] [[CLASS alloc]]init] [类型/对象 方法]">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2022-05-02T02:45:22.336Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Objective-C语法点">
<meta name="twitter:description" content="OC特点OC没有命名空间，对象的成员变量是默认受保护的。 弱类型语言，单继承 init系统自带的初始化方法，默认是给基本数据类型赋值0，0.0，指针赋值NULL，对象指针类型赋值nil  本质上都是(void *)0 [CLASS  new] [[CLASS alloc]]init] [类型/对象 方法]">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"right","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://pabebezz.github.io/article/d97699bf/">


<meta name="google-site-verification" content="skUdQN9cQrZuUJydKG0ivzB90q5kyLJMU5i5dt82GH4">
<meta name="google-site-verification" content="hv7_j7TFqTy83_mHkj5EDOJhzIl0_tusCnHJBxNOfAo">






  <title>Objective-C语法点 | Pabebe's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail">
    <div class="headband"> 
       
    </div>
 

      <!-- change "fork me on github" -->
     <!--  <a href="https://github.com/Pabebezz" target="_blank" ><img style="position: absolute; top: 0; right: 1200; border: 0;"  width="149" height="149" src="/images/forkme_left_green.png" class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a> -->
     <a href="https://github.com/Pabebezz" class="github-corner" target="_blank" aria-label="View source on GitHub"><svg width="80" height="80" viewbox="0 0 250 250" style="fill: #326755; color:#fff; position: absolute; top: 0; border: 0; left: 0; transform: scale(-1, 1);" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    
       
       <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Pabebe's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">业精于勤，荒于嬉；行成于思，毁于随。</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>





 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://pabebezz.github.io/article/d97699bf/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Pabebe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pabebe's Blog">
    </span>

    
      <header class="post-header">
        

        
        
          <h1 class="post-title" itemprop="name headline">Objective-C语法点</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-11-10T17:10:18+08:00">
                2021-11-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/IOS/" itemprop="url" rel="index">
                    <span itemprop="name">IOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
           
           
            <span class="post-meta-divider">|</span>
            <span id="busuanzi_value_page_pv"></span>次阅读
            

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  12.7k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  49 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="OC特点"><a href="#OC特点" class="headerlink" title="OC特点"></a>OC特点</h1><p>OC没有命名空间，对象的成员变量是默认受保护的。</p>
<p>弱类型语言，单继承</p>
<p>init系统自带的初始化方法，默认是给基本数据类型赋值0，0.0，指针赋值NULL，<strong>对象</strong>指针类型赋值<strong>nil</strong>  本质上都是(void *)0</p>
<p>[CLASS  new]</p>
<p>[[CLASS alloc]]init]</p>
<p>[类型/对象 方法]</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">重写init</span><br><span class="line">-(instancetype)init&#123;</span><br><span class="line">    // self若为nil说明生成实例失败</span><br><span class="line">    if(self = [super init])&#123;</span><br><span class="line">        初始化代码</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line">//带参构造函数</span><br><span class="line">-(instancetype)initWithName:(NSString *)name andAge:(int)age&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//调用</span><br><span class="line">类名 *p = [[类名 alloc] init]; // [类名 new];</span><br><span class="line">类名 *p = [[类名 alloc] initWithName: @&quot;xx&quot; andAge:18];</span><br><span class="line"></span><br><span class="line">多参数方法 (标签)</span><br><span class="line">    //实际函数名 setName: age: height:</span><br><span class="line">- (void)setName：(NSString*)name age:(NSInteger)myAge height:(NSInteger)myHeight;</span><br><span class="line">[classname setName:@&quot;zz&quot; age:18 height：1]；</span><br><span class="line">    </span><br><span class="line">实例方法（对象方法）</span><br><span class="line">-(返回值类型) 方法名:(参数类型)参数名:(参数类型)参数名 ; or &#123;&#125;</span><br><span class="line">_age;</span><br><span class="line">setAge();</span><br><span class="line">getAge();</span><br><span class="line"></span><br><span class="line">类方法</span><br><span class="line">+ ()函数名：(参数类型)参数； 类似与C++static类静态函数 ，而OC中static只能修饰局部变量</span><br></pre></td></tr></table></figure>
<h2 id="【待补充】实例对象、类对象（class-object）与元类对象-metaclass-object"><a href="#【待补充】实例对象、类对象（class-object）与元类对象-metaclass-object" class="headerlink" title="【待补充】实例对象、类对象（class object）与元类对象(metaclass object)"></a>【待补充】实例对象、类对象（class object）与元类对象(metaclass object)</h2><p>实例对象：当我们在代码中new一个实例对象时，拷贝了实例所属的类的成员变量，但不拷贝类定义的方法。调用实例方法时，根据实例的isa指针去寻找方法对应的函数指针。</p>
<p>类对象：是一个功能完整的对象。特殊之处在于它们是由程序员定义而在运行时由编译器创建的，它没有自己的实例变量（这里区别于类的成员变量，他们是属于实例对象的，而不是属于类对象的，类方法是属于类对象自己的），但类对象中存着成员变量与实例方法列表。</p>
<p>元类对象：OC 的类方法是使用元类的根本原因，因为其中存储着对应的类对象调用的方法即类方法。其他时候都倾向于隐藏元类，因此真实世界没有人发送消息给元类对象。元类的定义和创建看起来都是编译器自动完成的，无需人为干涉。要获取一个类的元类，可使用如下定义的函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Class <span class="title">objc_getMetaClass</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name)</span></span>; <span class="comment">//name为类的名字</span></span><br></pre></td></tr></table></figure>
<p>此外还有一个获取对象所属的类的函数：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class object_getClass(<span class="name">id</span> obj) <span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>由于类对象是元类的实例，所以当传入的参数为类名时，返回的就是指向该类所属的元类的指针。</p>
<p>参考文章：</p>
<p><a href="https://blog.csdn.net/u010067452/article/details/54907681" target="_blank" rel="noopener">对象与元类对象</a></p>
<p><a href="https://blog.csdn.net/beclosedtomyheart/article/details/50164353?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-1.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-1.pc_relevant_default&amp;utm_relevant_index=2" target="_blank" rel="noopener">清晰理解Objective-C元类</a></p>
<h1 id="【待补充】消息机制"><a href="#【待补充】消息机制" class="headerlink" title="【待补充】消息机制"></a>【待补充】消息机制</h1><p><a href="https://blog.csdn.net/ochenmengo/article/details/104943499?spm=1001.2101.3001.6650.4&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-4.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-4.pc_relevant_default&amp;utm_relevant_index=9" target="_blank" rel="noopener">Runtime –对象、类对象、元类对象&amp;消息传递机制</a></p>
<p><a href="https://blog.csdn.net/ochenmengo/category_9779027.html" target="_blank" rel="noopener">iOS面试题笔记</a></p>
<h2 id="总结取到类在代码段中的地址的方式．"><a href="#总结取到类在代码段中的地址的方式．" class="headerlink" title="总结取到类在代码段中的地址的方式．"></a>总结取到类在代码段中的地址的方式．</h2><p>1.调试查看对象的isa指针的值.</p>
<p>2.在类方法中查看self的值.(相当于C++的this, 但在<strong>对象方法</strong>【动态分配内存，调用完成后会释放内存】中,self不可以以调用类方法，因为此时self代表对象；在<strong>类方法</strong>【在应用程序开始运行时一直驻于内存】中，self代表类，不可以调用对象方法与属性，只能通过实例化一个对象来调用对象方法与属性。可以总结：在实例方法中self是object，而在类方法中self是class，所以在两种方法内部无法通过self来相互调用，self只能调用相同类型的方法。)  </p>
<p>3.调用对象的对象方法class 就会返回这个对象所属的类在代码段中的地址.</p>
<p>4.调用类的类方法class 就会返回这个类在代码段中的地址.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class c1 = [类名 class];  //此时 c1 等价于 该类，只能调用该类的类方法</span><br><span class="line">Class c2 = [类的实例化对象 class];</span><br><span class="line">NSLog(@&quot;其地址：@%p&quot;,[类名 class]);</span><br></pre></td></tr></table></figure>
<p>私有属性：在implementation{}中声明【这样Xcode不会提示】</p>
<p>私有方法：在类中只实现，不声明</p>
<h2 id="类与方法在代码段中的存储方式与调用机制"><a href="#类与方法在代码段中的存储方式与调用机制" class="headerlink" title="类与方法在代码段中的存储方式与调用机制"></a>类与方法在代码段中的存储方式与调用机制</h2><p> Class对象与SEL对象定义过程中便已经是<strong>指针</strong>了。</p>
<p>（1）类以 Class对象的形式存储在代码段中，包括类名、方法、属性、isa指针（继承于NSObject【包含了NS类中所有的基本属性和方法】）。</p>
<p>当对象的实例方法被调用，是通过isa来找到对应的类，然后在该类的class_data_bits_t中去查找方法。class_data_bits_t是指向了类对象的数据区域。在该数据区域内查找相应方法的对应实现。</p>
<p>（2）方法存储于SEL对象【selector 选择器】中，再将该SEL对象作为类对象的属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SEL s1 = @selector(方法名);</span><br><span class="line">NSLog(@&quot; s1 = %p&quot;, s1);//输出</span><br><span class="line"></span><br><span class="line">[类名 方法名]</span><br><span class="line">内部为：得到存储方法的SEL消息，发送给类对象，根据对象的isa指针找到存储类的类对象，在内部从查找有关SEL数据匹配的，有就执行；若没有在找父类内部直至NSObject. 均无则报错</span><br><span class="line"></span><br><span class="line">等价于</span><br><span class="line">SEL s1 = @selector(方法名);//若方法带参数，要加:</span><br><span class="line">[p1 performSelector:s1]; //不带参数</span><br><span class="line"></span><br><span class="line">[p1 performSelector:s1 withObject:参数值]; //带参数（至多两个，多于2个用构造参数类或参数结构体）</span><br></pre></td></tr></table></figure>
<p>调用的本质是利用OC的消息机制，即给类对象发送SEL消息。</p>
<h2 id="点语法"><a href="#点语法" class="headerlink" title="点语法"></a>点语法</h2><p>对象.去掉下划线的属性 本质是转换为 调用对应属性的getter/setter方法</p>
<p>即[对象 set/get去掉下划线的属性名首字母大写(:数据)]</p>
<p>这就是<strong>命名规范</strong>的重要性【属性前面下划线，set/get去掉下划线的属性名首字母大写】。</p>
<p>当不存在set/get函数或set/get函数命名有误，则不能使用点语法</p>
<h2 id="NSLog与printf的区别"><a href="#NSLog与printf的区别" class="headerlink" title="NSLog与printf的区别"></a>NSLog与printf的区别</h2><p>printf(暴力调试)</p>
<p>NSlog(检测当前程序，添加了时间戳，工程名字，进程号，线程号，自动换行)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;%@&quot;,CLASSNAME.obj)</span><br><span class="line">// description 快速打印类中所有成员，属于NSObject类，不能显式调用</span><br></pre></td></tr></table></figure>
<h2 id="NSObject和id的异同"><a href="#NSObject和id的异同" class="headerlink" title="NSObject和id的异同"></a>NSObject和id的异同</h2><p>相同点：万能指针都可以执行任意的oc对象，<br>不同点：通过NSObject指针去调用对象的方法的时候，编译器会做编译检查，<br>通过id类型的指针去调用对象的方法的时候，编译器直接通过，无论你调用什么方法.<br>注意：1.指针只能调用对象的方法不能使用点语法，如果使用点语法就会直接报编译错误·<br>          2.如果我们要声明1个万能指针千万不要使用NS0 bject而是用id</p>
<h2 id="id和instancetype的区别-泛型类型"><a href="#id和instancetype的区别-泛型类型" class="headerlink" title="id和instancetype的区别(泛型类型)"></a>id和instancetype的区别(泛型类型)</h2><p>i),instancetype只能作为方法的返回值.不能在别的地方使用；<br>id既可以声明指针变量也可以作为参数也可以作为返回值，<br>2).instancetype是有类型的，代表当前类的对象；<br>id是1个无类型的指针仅仅是1个地址，没有类型的指针。</p>
<p>方法 若内部在创建当前类的对象，用[self new]。若返回当前类的对象，用instance。 </p>
<h2 id="＠class（类前置声明）与＃import的区别"><a href="#＠class（类前置声明）与＃import的区别" class="headerlink" title="＠class（类前置声明）与＃import的区别"></a>＠class（类前置声明）与＃import的区别</h2><p>当两个类相互包含的时候【当Person.h中包含Book.h而Book.h中又包含Person.h 】，就会出现循环引用的问题，就会造成无限递归的问题，而导致无法编译通过.</p>
<p>解决方案：<br>（1）其中一边不要使用＃import引入对方的头文件。使用＠class 类名；来标注这是1个类，这样子就可以在不引入对方头文件的情况下，告诉编译器这是1个类。<br> （2）在.m文件中再＃import对方的头文件，就可以使用了。</p>
<p>区别 :<br>1）＃import是将指定的文件的内容拷贝到写指令的方。<br>2）＠class 并不会拷贝任何内容，只是告诉编译器，这是1个类，这样编译器在编译的时候才可以知道这是1个类。</p>
<h2 id="OC支持参数个数不同的函数重载"><a href="#OC支持参数个数不同的函数重载" class="headerlink" title="OC支持参数个数不同的函数重载"></a>OC支持参数个数不同的函数重载</h2><p>如果参数个数相同，无论参数和返回值类型相同与否都无法编译通过。</p>
<h2 id="struct与class的区别"><a href="#struct与class的区别" class="headerlink" title="struct与class的区别"></a>struct与class的区别</h2><p> （1）struct无继承</p>
<p>（2）struct 是值类型【写时复制】，class是引用类型</p>
<h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><h2 id="合成存取器【属性是为成员变量服务的】"><a href="#合成存取器【属性是为成员变量服务的】" class="headerlink" title="合成存取器【属性是为成员变量服务的】"></a>合成存取器【属性是为成员变量服务的】</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@property 属性名（去掉_的成员变量名）</span><br><span class="line">    作用：自动生成类属性的get/setget/set方法的声明【写在类的声明interface大括号外，end前】，而编译器在编译过程中遇到@property自动生成类属性的get/set方法的实现。</span><br><span class="line">     使用： @property 数据类型 成员变量名</span><br><span class="line">(1)点运算访问成员变量 本质是调用了set/get方法</span><br><span class="line">(2)可以直接由属性声明成员变量（会自动生成 _属性名 的成员变量）</span><br><span class="line">(3)synthesize 自定义 【自动生成的成员变量名】</span><br><span class="line">    eg: synthesize name = _myName; </span><br><span class="line"></span><br><span class="line">@property【自动生成属性getter/setter方法的声明，写在interface大括号外，end前】</span><br><span class="line">@synthesize 【自动生成属性getter/setter方法的实现，写在implementation中】自动生成真私有的（即不被XCode提示）属性（不带下划线的）以及getter/setter方法（均是处理所自动生成的属性值）</span><br><span class="line">@synthesize 属性名 = 已声明（带下划线的）属性名 【指定操作】</span><br><span class="line">@property在XCode4.4加强，可以自动生成（带下划线的）私有属性以及对应属性getter/setter方法的声明与实现。</span><br><span class="line">PS: 同时重写 getter、setter方法 、@property则不会自动生成私有属性。</span><br></pre></td></tr></table></figure>
<h2 id="常用修饰词"><a href="#常用修饰词" class="headerlink" title="常用修饰词"></a>常用修饰词</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property(修饰词1,修饰词2,...)数据类型 名称;</span><br></pre></td></tr></table></figure>
<h3 id="属性类型相关"><a href="#属性类型相关" class="headerlink" title="属性类型相关"></a>属性类型相关</h3><p>assign 默认，一般用于非OC对象类型的属性 （生成的setter方法的实现：直接赋值）</p>
<p><strong>OC对象类型</strong></p>
<p>【MRC模式】retain 用于OC对象类型的属性（生成的setter方法的实现：为标准MRC内存管理代码，<strong>需要手动在本类的dealloc中释放</strong>）<br>【ARC模式】strong/weak (强弱指针涉及到对象的引用计数)</p>
<p>copy 多用于NSString类型的属性【深拷贝】</p>
<h3 id="线程相关"><a href="#线程相关" class="headerlink" title="线程相关"></a>线程相关</h3><p>nonatomic 默认，适用单线程<br>atomic 多线程程序(setter方法的代码会加上一把线程安全锁)</p>
<h3 id="访问权限相关"><a href="#访问权限相关" class="headerlink" title="访问权限相关"></a>访问权限相关</h3><p>readonly 只生成getter方法<br>readwrite 生成getter/setter方法</p>
<h3 id="方法生成相关"><a href="#方法生成相关" class="headerlink" title="方法生成相关"></a>方法生成相关</h3><p>setter 自定义生成的setter方法名（带参要加:）<br>getter 自定义生成的getter方法名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@property(nonatomic,assign,getter=isMan,setter=XYZ:)BOOL sex;</span><br><span class="line">//对应getter/setter方法</span><br><span class="line">-isMan();</span><br><span class="line">-XYZ:(BOOL sex);</span><br><span class="line"></span><br><span class="line">在使用点语法，编译器直接调用 自定义的getter/setter方法名</span><br></pre></td></tr></table></figure>
<h1 id="类的扩展"><a href="#类的扩展" class="headerlink" title="类的扩展"></a>类的扩展</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>将一个类分为多个模块，或者为已经存在的类添加方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@interface 类名(分类名)</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation 类名(分类名)</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<p>1．分类只能增加方法，不能增加属性</p>
<p>2．在分类之中可以写＠property, 但是不会自动生成私有属性,也不会自动生成getter setter的实现。<br><strong>只会生成getter setter的声明</strong>。 所以，需要在本类中定义属性且 分类中完成getter 和setter的声明。</p>
<p>3．在分类的方法实现中不可以直接访问本类的<strong>真私有属性</strong>（定义在本类的＠implementation之中）但是可以调用本类的getter setter来访问属性。<br>即本类的＠property生成的私有属性，只可以在本类的实现中访问。分类中不能直接访问<strong>真私有属性</strong>，但可以使用 getter setter 来访问。</p>
<p>4．当分类中有和本类中同名的方法的时候，优先调用分类的方法，哪怕没有引入分类的头文件。如果多个分类中有相同的方法，优先调用最后编译的分类。【TARGETS-&gt;Build Phases -&gt; Compile Sources 查看文件编译顺序】</p>
<h2 id="延展"><a href="#延展" class="headerlink" title="延展"></a>延展</h2><p>是一个特殊的分类，没有名字，没有实现。<br>只有声明，和本类共享一个实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@interface 类名()</span><br><span class="line">    //属性</span><br><span class="line">    //方法声明，在本类中实现</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>主要用途：（真）私有化类的成员</p>
<p><strong>eg:</strong>要为类写1个私有的＠property．且生成getter、setter方法只能在类的内部访问 不能在外部访问。<br><strong>解决方案：</strong>延展100％的情况下不会独占1个文件，都是<strong>将延展直接写在本类的实现文件</strong>（常见于ios UI 私有控件）中。这个时候，写在延展中的成员，就相当于是这个类的私有成员。只能在本类的实现中访问。外部不能访问。</p>
<h3 id="真私有属性"><a href="#真私有属性" class="headerlink" title="真私有属性"></a>真私有属性</h3><p>如果想要为类写1个真私有属性，虽然我们可以定义在＠implementation之中，但是不要这么写 这样很不规范。写1个延展。将<strong>这个私有属性声明在延展中</strong>．</p>
<p>如果要为类写1个<strong>私有方法</strong>，建议<strong>将声明写在延展中，实现写在本类的实现中</strong>，提供代码的阅读性如果想要为类写1个私有的＠property 就直接写在延展就可以了，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">实现方式一：【不推荐】</span><br><span class="line">@interface 类名&#123;</span><br><span class="line">    @private</span><br><span class="line">    //属性...  【xcode仍能够有提示，可以调用get/set方法间隔访问】</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation 类名&#123;</span><br><span class="line">    //属性...【真私有属性，xcode都不会提示，同时get/set方法只能在类的内部访问，不能在外部访问】</span><br><span class="line">    *** XXX;</span><br><span class="line">&#125;</span><br><span class="line">-(void)setXXX:(***)XXX</span><br><span class="line">&#123;</span><br><span class="line">    _XXX = XXX;</span><br><span class="line">&#125;</span><br><span class="line">-(***)getXXX</span><br><span class="line">&#123;</span><br><span class="line">    return XXX;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line">    </span><br><span class="line">实现方式二：</span><br><span class="line">在本类的.m文件中,使用延展</span><br><span class="line">#import &quot;类名.h&quot;</span><br><span class="line">@interface 类名()</span><br><span class="line">    @property (nonatomic, ...) ***XXX;</span><br><span class="line">@end</span><br><span class="line">@implementation 类名</span><br><span class="line">    </span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h2 id="延展和分类的区别"><a href="#延展和分类的区别" class="headerlink" title="延展和分类的区别"></a>延展和分类的区别</h2><p>1．分类有名字，延展没有名字 是1个匿名的分类。</p>
<p>2．每1个分类都有单独的声明和实现，而延展只有声明 没有单独的实现 和本类共享1个实现，</p>
<p>3．分类中只能新增方法，而延展中任意的成员（属性、方法）都可以写．</p>
<p>4．分类中可以写＠property 但是只会生成getter setter的声明。</p>
<p>延展中写＠property 会自动生成私有属性也会生成getter setter的声明和实现。</p>
<h1 id="block"><a href="#block" class="headerlink" title="block"></a>block</h1><p>block 是一种存储一段代码的数据类型，<strong>类似于C++函数指针</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">返回值类型 (^block变量名)(参数列表) = ^返回值类型(参数列表)&#123;</span><br><span class="line">   // 代码段</span><br><span class="line">&#125;</span><br><span class="line">//简写 当将blockf为函数的返回值的时候,返回值的类型就必须要使用typedef定义的短类型</span><br><span class="line">typedef 返回值类型 (^block变量名)(参数列表);</span><br><span class="line">eg: 定义了新类型 NewType 本质是 一个拥有两个int参数、返回int的block</span><br><span class="line">typedef int (^NewType) (int num1,int num2);</span><br><span class="line">NewType t1 = ^int(int num1, int num2)&#123;</span><br><span class="line">    int num3 = num1 + num2;</span><br><span class="line">    return num3;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="block简写规则"><a href="#block简写规则" class="headerlink" title="block简写规则"></a>block简写规则</h2><p><strong>代码段简写</strong></p>
<p>1.如果代码段没有返回值。那么代码段的void可以省略，</p>
<p>2.如果我们写的代码段没有参数，那么代码段的小括弧写可以省路。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//综上两条</span><br><span class="line">int (^myBlock2)() = ^&#123;</span><br><span class="line">        intnum1=10+20;</span><br><span class="line">        return num1 ;</span><br><span class="line">    &#123;</span><br></pre></td></tr></table></figure>
<p>3.无论代码段是否有返回值，在写代码的时候省略返回值类型。<br>这个时候系统会自动的确定返回值的类型【代码段中没有返回任何数据为void,有返回数据则为对应类型】。</p>
<p><strong>声明block变量简写</strong></p>
<p>4.声明block变量的时候，如果有指定参数，可以只写参数的类型而不写参数的名称;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//综上两条</span><br><span class="line">int (^myBlock3)(int,int) = ^(int num1, int num2)&#123;</span><br><span class="line">    int num3= numl + num2;</span><br><span class="line">    return num3;//自动确认返回int型</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="block访问外部变量"><a href="#block访问外部变量" class="headerlink" title="block访问外部变量"></a>block访问外部变量</h2><p>1.在block代码块的内部可以<strong>读取</strong>定义在外部的变量的值【包括全局变量和在外部的局部变量】。<br>2.在block代码块的内部可以<strong>修改全局变量</strong>的值，但是不能修改在外部的局部变量的值【若要修改，该变量需添加<code>_ _block</code>的修饰符】。</p>
<h2 id="block与函数的区别"><a href="#block与函数的区别" class="headerlink" title="block与函数的区别"></a>block与函数的区别</h2><p>相网点:都是封装1段代码，<br>不同点:</p>
<ol>
<li>block是1个数据类型。 函数是1个函数。</li>
<li>我们可以声明black类型的安量函数就只是函数。</li>
<li>block可以作为函数的参数。而函数不能直接作为函数的参数.</li>
</ol>
<h1 id="协议protocol"><a href="#协议protocol" class="headerlink" title="协议protocol"></a>协议protocol</h1><p>专门用来声明一大堆方法【.h并且只有1个.h文件.】。(不能声明属性,也不能实现方法,只能用来写方法的声明).只要某个类遵守了这个协议.就相当于拥有这个协议中的所有的方法声明。<strong>相当于C++中的纯虚函数</strong></p>
<h2 id="类是单继承，可以多协议"><a href="#类是单继承，可以多协议" class="headerlink" title="类是单继承，可以多协议"></a>类是单继承，可以多协议</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@protocol协议名称&lt;NS0bject&gt;</span><br><span class="line">    @required</span><br><span class="line">    //方法的声明;【遵守这个协议的类必须要实现这个方法,否则编译器会发出警告.】 </span><br><span class="line">    @optional</span><br><span class="line">   // 方法的声明; 【遵守这个协议的类如果不实现这个方法.编译器也不会报警告.】</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">//当1个类遵守了多个协议之后,就相当于这个类拥有了所有协议中定义的方法的声明。那么这个类,就应该实现所有协议中的方法.当创建对象,来调用这个没有实现的协议中的方法的时候就会报错。</span><br><span class="line">@interface类名:父类名&lt;协议 名称1,协议名称......&gt;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h2 id="协议与协议之间可以相互继承"><a href="#协议与协议之间可以相互继承" class="headerlink" title="协议与协议之间可以相互继承"></a>协议与协议之间可以相互继承</h2><p>NSObject协议被NS0bject类遵守（类的名称可以和协议的名称一致）</p>
<p>要求所有的协议都必须直接的或者间接的从<strong>NS0bject基协议</strong>继承。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//子协议中不仅有自己的方法的声明,还有父协议中的所有的方法的声明.如果1个类遵守了某份协议,那么这个类就拥有这个协议和这个协议的父协议中的所有的方法声明。</span><br><span class="line">@protocol协议名称&lt; 父协议名称&gt;</span><br><span class="line">     // 方法的声明</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h2 id="协议类型限制指针"><a href="#协议类型限制指针" class="headerlink" title="协议类型限制指针"></a>协议类型限制指针</h2><p>声明1个指针变量，要求这个指针变量指向的对象必须遵守多个协议。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// obj1是遵守StudyProtocol, SBProtocol协议的指针，其指向的对象也必须遵守StudyProtocol, SBProtocol协议。</span><br><span class="line">NSObject&lt;StudyProtocol, SBProtocol&gt; *obj1 = [Student new];</span><br><span class="line">id&lt;StudyProtocol, SBProtocol&gt; obj1 = [Student new];</span><br></pre></td></tr></table></figure>
<p>2).效果:<br>子协议中不仅有自己的方法的声明,还有父协议中的所有的方法的声明.<br>如果1个类遵守了某份协议,那么这个类就拥有这个协议和这个协议的父协议中的所有的方法声明。<br>2.介绍1个东西. NSObject<br>在Foundation框架中,有1个类叫做NSObject 是所有0C类的基类。<br>在Foundation框架中,有1个协议。叫做NSObject.<br>NSObject协议被NS0bject类遵守.所以,NSObject协议中的所有的方法全部的0C类都拥有了.<br>这么说，所有的0C类都遵守了NSObject协议。NSObject协议叫做基协议。<br>类的名称可以和协议的名称-致。<br>3.写协议的规范:<br>要求所有的协议都必须直接的或者间接的从NS0bject基协议继承。</p>
<h1 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h1><p>编译检查：在编译时，能不能调用对象的方法主要看指针所属类型。（看左边）<br>运行检查：在运行时，能不能调用对象的方法主要看指针所指向对象类型。（看右边）</p>
<p><a href="https://blog.csdn.net/Li_Ning_/article/details/51872201" target="_blank" rel="noopener">C++的多态性内部实现</a>—迟绑定</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1）．判断对象中是否有这个方法可以执行．【实例方法】</span><br><span class="line">- (BOOL) respondsToSelector:(SEL)aSelector; </span><br><span class="line"></span><br><span class="line">2）．判断类中是否有指定的类方法。【类方法】</span><br><span class="line">+(BOOL)instancesRespondToSelector:(SEL)aSelector; </span><br><span class="line"></span><br><span class="line">3）．判断指定的对象是否为 指定类的对象或者子类对象。</span><br><span class="line">- (BOOL)isKind0fClass: (Class)aClass;</span><br><span class="line">BOOL b1= [s1 isKindOfClass:[Person class]]; 判断s1对象是否为Person对象或者Person的子类对象。</span><br><span class="line">    </span><br><span class="line">4）．判断对象是否为指定类的对象 不包括子类．</span><br><span class="line">- (BOOL) isMember0fClass: (Class)aClass; </span><br><span class="line">[s1 isMemberofClass:[Student class]];</span><br><span class="line">判断s1对象是否为1个Student对象，不包括Student的子类对象．</span><br><span class="line"></span><br><span class="line">5）．判断类是否为另外1个类的子类。</span><br><span class="line">+(BOOL)isSubclass0fClass:(Class)aClass;</span><br></pre></td></tr></table></figure>
<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><p>只需要管理存储在<strong>堆上的OC对象</strong>的生成与释放(本质是<strong>所占用内存的权限变更</strong>)</p>
<h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">1)．为对象发送1条retain消息。对象的引用计数器就会加1．当多1个人使用对象的时候才发。</span><br><span class="line">2)．为对象发送1条release消息．对象的引用计数器就会减1．当少1个人使用对象的时候才发。</span><br><span class="line">3)．为对象发送1条retainCount消息。就可以去到对象的引用计数器的值。</span><br><span class="line">4)当对象的引用计数器变为0的时候，对象就会被系统立即回收。在对象被回收的时候。会自动调用对象的dealloc方法.【在MRC模式下，可以重写dealloc方法，在最后需要调用[super dealloc]】</span><br><span class="line"></span><br><span class="line">注意事项：</span><br><span class="line">在MRC模式下，setter传递OC对象【注意NSString类】时应注意内存泄漏：</span><br><span class="line"> (1) setter传入对象时 旧对象的泄露</span><br><span class="line">(void)setCar:(Car *)car &#123;</span><br><span class="line">    //判断是否为同一对象</span><br><span class="line">	if(_car != car)&#123;</span><br><span class="line">        // 释放旧对象, 旧对象的引用计数--；</span><br><span class="line">        [_car release];</span><br><span class="line">        // 接收新对象, 新对象的引用计数++；</span><br><span class="line">        car = [car retain];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">或者 @property(nonatomic, retain) Car *car;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 本类资源释放</span><br><span class="line">-(void) dealloc&#123;</span><br><span class="line">    [_car release]; </span><br><span class="line">    [super dealloc];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(2)循环引用</span><br><span class="line">解决方案</span><br><span class="line">    【MRC模式】</span><br><span class="line">          1端使用使用 retain, 另一端使用assign,且dealloc中不需要release</span><br><span class="line">    【ARC模式】</span><br><span class="line">    	  1端使用使用 strong, 另一端使用weak</span><br></pre></td></tr></table></figure>
<h2 id="僵尸对象"><a href="#僵尸对象" class="headerlink" title="僵尸对象"></a>僵尸对象</h2><p>1个已被释放的对象，但其空间还未分配给别人，无法复活僵尸对象（这脑洞笑死）。【打开僵尸对象实时检查机制】</p>
<h2 id="野指针"><a href="#野指针" class="headerlink" title="野指针"></a>野指针</h2><p>C语言中的野指针：定义1个指针变量，没有初始化，这个指针变量的值是1个垃圾值，指向1块随机的空间。</p>
<p>OC中的野指针：指针指向的对象已经被回收了</p>
<p>解决：<strong>【设为nil，但调用对象的方法（包括点语法）时Xcode不会报错，只是没有任何反应；-&gt;访问属性会报错】</strong></p>
<h3 id="衍生出：objc中向一个nil对象发送消息将会发生什么？"><a href="#衍生出：objc中向一个nil对象发送消息将会发生什么？" class="headerlink" title="衍生出：objc中向一个nil对象发送消息将会发生什么？"></a>衍生出：<a href="https://www.jianshu.com/p/9a670004759c" target="_blank" rel="noopener">objc中向一个nil对象发送消息将会发生什么？</a></h3><p>首先了解消息发送机制以及isa指针的作用。</p>
<p>isa指针是用于对象指向类对象，类对象指向元类对象的一个指针。而类对象和元类对象中又分别存放对象方法和类方法。 在消息传递机制中，就是通过isa指针来寻找到方法的实际调用地址的。</p>
<p>objc在向一个对象发送消息时，runtime库会根据对象的isa指针找到该对象实际所属的类，然后在该类中的方法列表以及其父类方法列表中寻找方法运行，然后在发送消息的时候，objc_msgSend方法不会返回值，所谓的返回内容都是具体调用时执行的。 </p>
<p>如果向一个nil对象发送消息，首先在寻找对象的isa指针时就是0地址返回了，所以不会出现任何错误。给nil发送消息直接return，所以不会发生崩溃。<br> null是NSNull的实例，给这个对象发送一个它无法响应的消息自然会发生崩溃，报错：unrecognized selector</p>
<h2 id="autoreleasepool-自动释放池"><a href="#autoreleasepool-自动释放池" class="headerlink" title="autoreleasepool (自动释放池)"></a>autoreleasepool (自动释放池)</h2><p>作用：清理动态分配对象【由工厂模式创建的、自动释放池对象】</p>
<p>自动释放池的原理：存入到自动释放池中的对象【不会使得对象的引用计数器++】，在自动释放池被销毁的时候自动调用<strong>存储在该自动释放池中的所有对象</strong>的release方法【不一定会直接销毁对象】。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@autoreleasepool &#123;</span><br><span class="line">	Person *p1=[[[Person alloc] init] autorelease];</span><br><span class="line">	[p2 autorelease]; //autorelease 多次，也会发送多条release消息 【所以同一对象只autorelease1次】</span><br><span class="line">&#125;//代表这个自动释放池的范围</span><br></pre></td></tr></table></figure>
<h2 id="ARC机制"><a href="#ARC机制" class="headerlink" title="ARC机制"></a>ARC机制</h2><p>当ARC开启时，编译器会自动的在合适的地方播入retain、release、autorelase代码。</p>
<p><strong>本质</strong>：对象的引用计数器为0的时候，自动释放。</p>
<p><strong>表象</strong>：只要没有强指针指向这个对象【即指向该对象的所有强指针被回收或赋值为nil】，这个对象就会立即回收。此时，指向该对象的所有弱指针均被赋值为nil</p>
<h3 id="强指针与弱指针"><a href="#强指针与弱指针" class="headerlink" title="强指针与弱指针"></a>强指针与弱指针</h3><p>强指针：＿strong标识或者默认情况的指针</p>
<p>弱指针：＿weak标识的指针</p>
<p>无论是强指针还是弱指针，都是指针，都可以用来存储地址，都可以通过这个指针访问对象的成员。</p>
<p>唯一的区别就是在ARC模式下，他们用来作为回收对象的基准。</p>
<h3 id="property-禁用retain"><a href="#property-禁用retain" class="headerlink" title="@property 禁用retain"></a>@property 禁用retain</h3><p>ARC机制不需要，对于OC对象属性会自动生成符合MRC标准的内存管理代码</p>
<h3 id="禁用"><a href="#禁用" class="headerlink" title="禁用"></a>禁用</h3><p>（1）不允许调用retain、release、retainCount、autorelease 方法</p>
<p>（2）在dealloc中不允许[super dealloc]</p>
<h3 id="ARC机制-与-垃圾回收机制GC的区别"><a href="#ARC机制-与-垃圾回收机制GC的区别" class="headerlink" title="ARC机制 与 垃圾回收机制GC的区别"></a>ARC机制 与 垃圾回收机制GC的区别</h3><p>GC 在运行时通过各种策略扫描堆中没有在使用的对象并回收。</p>
<p>ARC 在编译时插入retain、release、autorelase代码，可以满足对象引用计数为0时便释放。</p>
<h1 id="【待补充】动态特性"><a href="#【待补充】动态特性" class="headerlink" title="【待补充】动态特性"></a>【待补充】动态特性</h1><h2 id="动态类型"><a href="#动态类型" class="headerlink" title="动态类型"></a>动态类型</h2><h2 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h2><h2 id="动态加载"><a href="#动态加载" class="headerlink" title="动态加载"></a>动态加载</h2><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="NSString"><a href="#NSString" class="headerlink" title="NSString"></a>NSString</h2><p>NSString 不可变字符串，即当在内存中创建1个字符串对象以后.这个字符串对象的内容就无法更改【无论在常量区还是堆区】。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSString *str = @&quot;jack&quot;; //0C字符串常量存储在常量区(数据段)</span><br><span class="line"></span><br><span class="line">NSString *str =[NSString stringWithFormar:@&quot; jack&quot;];//调用NSString的类方法来创建对象的时候。创建的字符串对象是存储在堆区。</span><br></pre></td></tr></table></figure>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>1.当我们重新为字符串指针初始化值的时候.并不是修改原来的字符串对象而是重新的创建1个字符串对象。将这个字符串对象的地址重新复制给字符串指针变量。<br>2.当系统准备要在内存中创建字符串对象的时候。会先检查内存中是否有相同内容的字符串对象。如果有，直接指向。如果没有才会重新创建。<br>3.存储在常量区的数据不会被回收，所以存储在常量区的字符串对象也不会被回收。<br>4.stringbyappend后是申请了新内存，所以需要别的指针指向这一块内存。<br>NSMutableString appendString, 则是可变的<br>PS: OC中一个汉语字符长度为1，C中一个汉字两个字节【取决于编译器】用 unichar （unsigned short）来存储汉字字符</p>
<h3 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h3><p>1.无论在MRC还是ARC下 ,如果属性的类型是NSString类型的。<strong>@property参数使用copy.</strong></p>
<p>2.拷贝<br><strong>1).</strong>copy方法是定义在NSObject类中的1个方法。copy方法的内部调用了另外1个方法copyWithZone:<br>这个方法是定义在NSCoping协议之中的。【作用:拷贝对象。】<br>NSString —&gt; copy —&gt; 不可变字符串没有产生新对象 ,而是直接将对象本身的地址返回，浅拷贝。<br>NSMutableString –&gt; copy –&gt;是1个<strong>不可变</strong>的字符串对象，产生1个新对象，深拷贝<br><strong>2).</strong> mutableCopy.定义在NSObject类之中。作用:拷贝对象【深拷贝】。<br>NSString—&gt; mutableCopy –&gt;<strong>可变</strong>字符串对象,深拷贝.<br>NSMutabieString –&gt; mutableCopy –&gt;可变字符串对象,深拷贝。</p>
<p>3.字符串对象拷贝的引用计数器的问题。<br>1).若字符串对象存储在常量区中，存储在常量区的数据是<strong>不允许被回收</strong>的。<br>所以存储在常量区的字符串对象的引用计数器是<strong>1个超大的数</strong>，并且retain和release无效。<br>2).若字符串存储在堆区.这个字符串对象和普通的对象一样的.引用计数器默认是1.<br>3).字符串对象如果是浅拷贝，会将对象的引用计数器+1。字符串对象如果是深拷贝。原来的对象的引用计数器不变，新拷贝出来的对象的引用计数器为1.</p>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">1.使用拼接的方式创建1个NSString对象.</span><br><span class="line">  +(instancetype)stringWithFormat: (NSString *)format, ...</span><br><span class="line">  </span><br><span class="line">2.得到字符串的长度。</span><br><span class="line">  @property (readonly) NSUInteger length;</span><br><span class="line"></span><br><span class="line">3.得到字符串中指定下标的字符。</span><br><span class="line"> - (unichar) characterAtIndex: (NSUInteper) index;</span><br><span class="line">  返回值是unichar类型的要打印的话使用%C</span><br><span class="line"></span><br><span class="line">4.判断两个字符串的内容是否相同.</span><br><span class="line">  a.不能使用==来判断两个0C字符串的内容是否相同.因为==比较的是字符串指针变量的值.而我们要比的是两个字符串指针指向的字符串对象的内容是否相同。</span><br><span class="line">      - (BOOL) isEqualToString: (NSString *)aString;</span><br><span class="line">    就可以比较当前字符串对象和传入的字符串对象的内容是否相同. </span><br><span class="line">//==运算符的作用:比较左右两边的数据是否相同.</span><br><span class="line">  10 == 10这个时候 直接比较的是左右两边的数据是否相同.</span><br><span class="line">  a == b两边也可以写1个变量. 这个时候比较是左右两边的变量的值是否相同.</span><br><span class="line">  如果两边是1个指针变量.则比较的是指针变量的值是地址。</span><br><span class="line"> </span><br><span class="line">5. 将C语言的字符串转换为0C字符串对象。 </span><br><span class="line">  + (instancetype)stringWithString (NSString *)string;</span><br><span class="line"></span><br><span class="line">6.将0C字符串对象转换为C语言的字符串.</span><br><span class="line">    @property (nullable, readonly)_ _strong const char *UTF8String</span><br><span class="line"> </span><br><span class="line">7.从磁盘上的文件中读取文件中的内容。</span><br><span class="line">+ (instancetype) stringWithContentsOfFile: (NSString *)path encoding:(NSSt ringEncodingienc error: (NSError **)error;</span><br><span class="line"></span><br><span class="line">8.将字符串内存写入到磁盘上的某1个文件之中。</span><br><span class="line">- (BOOL)writeToFile: (NSString *)path atomically:(BOOL)useAuxiliaryFile encoding:</span><br><span class="line">(NSStringEncoding)enc error:(NSError **)error; </span><br><span class="line">参数1:将字符串内容写入到那1个文件之中写上文件的路径，</span><br><span class="line">参数2: YES先将内容写入到1个临时文件.如果成功再将这个文件搬到指定的目录。安全，效率较低。NO，直接将内容写入到指定的文件不安全，效率高【推荐使用NO】。</span><br><span class="line">参数3:指定写人的时候使用的编码。一般情况下这里写.NSUTF8StringEncoding使用UTF-8编码。</span><br><span class="line">参数4:二级指针，要传递1:个NSError指针的地址。</span><br><span class="line">如果写入成功这个指针的值就是nil</span><br><span class="line">如果写入失败，这个指针就会指向1个错误对象.这个对象描述了发生错误的信息。</span><br><span class="line">这个对象的localizedDescription方法可以得到发生错误的简要信息。</span><br><span class="line">所以我们要判断是否写入成功，也可以判断这个指针的值是否为nil</span><br><span class="line">如果不想知道发生错误的原因,那么第4个参数给nil就可以了.</span><br><span class="line">                                                                       </span><br><span class="line">9.使用NSURL读取字符串</span><br><span class="line">&gt;将本地文件路径封装在NSURL对象之中，</span><br><span class="line">NSURL *url = (NSURL URLWithString:@&quot;file://Users/Highven/Desktop/123.txt&quot;;</span><br><span class="line">&gt;将网页地址路径封装在NSURL对象之中.</span><br><span class="line">&gt;NSURL *url = (NSURL URIWithString:@&quot;http://zitcast.cn&quot;;</span><br><span class="line">&gt;將ftp文件路径封装在NSURL对象之中.</span><br><span class="line">&gt;NSURL *url = [NSURL URLWithSring:@&quot;ftp://server.itcast.cn/io/cjk.txt&quot;:</span><br><span class="line">&gt;4).读取NSURL对象中保持的路径的文件数据.</span><br><span class="line"></span><br><span class="line">+ (instancetype)stringwithContentsOfURl : (NSURL *)url encoding: (NSStringEncoding)enc error: (NSError **)</span><br><span class="line">  error;</span><br><span class="line">  第1个参数:封装了地址的NSURL对象.</span><br><span class="line">  第2个参数:编码方式.一般传递NSUTF8StringEncoding</span><br><span class="line">  第3个参数:二级指针.传入1个NSError的1个二级指针.如果方法执行成功则方法执行完毕之后,这个NSError的指针的值为nil</span><br></pre></td></tr></table></figure>
<h3 id="NSMutableString是NSString的子类"><a href="#NSMutableString是NSString的子类" class="headerlink" title="NSMutableString是NSString的子类."></a>NSMutableString是NSString的子类.</h3><p><strong>NSMutableString从NSString继承</strong>.存储在NSSMutableString对象中的字符串数据可以更改【不会新创建对象】.具备可变性，<br>NSMutbaleStrint: 做大批量的字符串拼接【10次以上】的时候才使用。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">NSMutableString *str = (NSMutableString string];</span><br><span class="line">//创建NSMutableString对象的时候， 记住下面这样的初始化方式是不行的。</span><br><span class="line">    NSMutableString *str = @&quot;jack&quot;;</span><br><span class="line">    @&quot;jack&quot;是1个NSString对象， 是1个父类对象。</span><br><span class="line">    而str指针是1个NSMutabiestring类型的是1个子类类型的。</span><br><span class="line">    如果通过子类指针去调用子类独有的成员就会运行错误。</span><br><span class="line">   </span><br><span class="line"> //往可变字符串对象中追加字符串。</span><br><span class="line">  - (void)appendString: SString *)aString; 直接追加内容. </span><br><span class="line">  - (void) appendFormat: (NSString *)format, ...以拼接的方式往可变字符串对象中追加内容.</span><br></pre></td></tr></table></figure>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>NSArray、NSDictionary字典就叫做集合.</p>
<p>在MRC的模式下将1个对象存储到集合中<br>（1）会影响对象的引用计数器.<br>    将对象存储到集合之中,会为这个对象的引用计数器+1<br>    当集合销毁的时候就会像存储在集合中的所有的对象发送1条release消息。<br>（2）使用@[]或者@{}创建的集合已经是被autorelease过的了.<br>    直接调用和类同名的类方 法创建的对象也是被autorelease过的了.</p>
<p>在ARC的模式下，集合的元素是1个强类型的指针。</p>
<h2 id="NSArray"><a href="#NSArray" class="headerlink" title="NSArray"></a>NSArray</h2><p>1).是Foundation框架中的一 一个类.这个类的对象是来存储多个数据的,具备数组的功能。<br>所以,NSArray是OC中的数组.<br>2).特点:<br>a.只能存储OC对象.任意的OC对象无法存储<br>b.长度固定。一旦NSArray数组创建完毕之 后,元素的长度固定,<strong>无法新增无法删除元素</strong>【nil为元素终止标识符】。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSArray *arr = [NSArray arrayWithobjects:@&quot;jack&quot; ,nil,@&quot;rose&quot; ,@&quot;lili&quot;,nil];</span><br><span class="line">// 简单模式： NSArray *arr = @[写上每1个元素的值用逗号分隔.]; 注意:这种创建方式 不需要在最后加nil</span><br><span class="line">NSArray *arr = @[@&quot;jack&quot; ,@&quot;rose&quot;,@&quot;lili&quot;];</span><br></pre></td></tr></table></figure>
<p>c.每1个元素都是紧密相连的。每1个元素仍然有自己的下标。<br>d.元素的类型是id类型的。</p>
<h3 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//取值</span><br><span class="line">// 可以直接 [index], 也可以使用如下方法</span><br><span class="line">- (ObjectType)objectAtIndex: (NSUInteger)index;</span><br><span class="line">NSArray *arr = @[@&quot;jack&quot; ,@&quot; rose&quot; ,@&quot;lili&quot;];</span><br><span class="line">NSString *str = [arr objectAtIndex:3]; </span><br><span class="line">NSLog(@&quot;*@&quot;,str);</span><br><span class="line"></span><br><span class="line">//遍历</span><br><span class="line">1.index 遍历</span><br><span class="line">2.for in 来遍历【推荐使用id类型，防止NSArray内部类型不一致】  </span><br><span class="line">3.使用block遍历。</span><br><span class="line">- (void) enumerate0bjectsUsingBlock: (void (^) (0objectType obj, NSUInteger idx, BOOL</span><br><span class="line">*stop))block</span><br><span class="line">    </span><br><span class="line">1.得到NSArray数组中的元素的个数。</span><br><span class="line">@property (readonly) NSUInteger count;</span><br><span class="line">2.判断NSArray数组中是否包含指定的元素。</span><br><span class="line">- (BOOL) containsObject: (ObjectType) an0bject;</span><br><span class="line">3.取到NSArray数组中的第1个元素.</span><br><span class="line">@property (nullable, nonatomic, readonly) ObjectType first0bject</span><br><span class="line">//与arr[0]的区别：如果数组中没有任何元素,arr[0]报错。firstObject取到nil 不报错。</span><br><span class="line">4.取到NSArray数组中的最后1个元素.</span><br><span class="line">@property (nullable, nonatomic, readonly) ObjectType lastobject</span><br><span class="line">5.查找指定的元素在NSArray数组中第一次出现的下标。</span><br><span class="line">- (NSUInteger) indexofobject: (ObjectType)anObject;</span><br><span class="line">如果没有找到返回的是NSUInteger的最大值.</span><br><span class="line"> </span><br><span class="line">6.将数组中的元素连接起来组成1个新的字符串.</span><br><span class="line">- (NSString *) componentsJoinedByString : (NSString *) separator</span><br><span class="line">参数:连接符.</span><br><span class="line"></span><br><span class="line">7.将字符串以指定的分隔符分成1个数组。每1部分就是 数组的1个元素.</span><br><span class="line">- (NSArray&lt;NSString *&gt; *)componentsSeparatedByString: (NSString F*)separator;</span><br></pre></td></tr></table></figure>
<h3 id="NSMutableArray是NSArray的子类"><a href="#NSMutableArray是NSArray的子类" class="headerlink" title="NSMutableArray是NSArray的子类."></a>NSMutableArray是NSArray的子类.</h3><ol>
<li>NSMubleArray仍然是1个数组.具备NSArray数组的特点。<br>只能存储OC对象.每1个元素的紧密相连的。</li>
<li>NSMutableArray相对于父类做的扩 展:NSMutableArray数组的元素<strong>可以动态的新增和删掉</strong>。<br>其他的用法均与NSArray-一致。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray *arr1 = [NSMutableArray new];</span><br><span class="line">NSMutableArray *arr2 = [[NSMutableArray alloc] init];</span><br><span class="line">NSMutableArray *arr3 = [NSMutableArray array];</span><br><span class="line">这样创建出来的数组对象.数组的元素是0仍然是有意义的因为我们可以动态的新增和删除元素。</span><br><span class="line">也可以使用这样的方式来创建可变数组对象.这个数组的元素可以新增和删除.</span><br><span class="line">NSMutableArray *arr4 = [NSMutableArray arrayWithobjects:@&quot;jack&quot; ,@&quot;rose&quot; ,@&quot;1ili&quot;, nil];</span><br><span class="line"></span><br><span class="line">//最容易犯错:这样写是不可以的</span><br><span class="line">NSMutableArray *arr5 = @[@&quot;jack&quot; ,@&quot;rose&quot; ,@&quot;1lil&quot;];</span><br><span class="line">//@[@&quot;jack&quot; ,@&quot; rose&quot; ,@&quot;lili&quot;];这是1个NSArray对象.arr5是1个子类指针。子类指针指向父类对象的就有可能会出问题。</span><br><span class="line"></span><br><span class="line">1.如何往可变数组中新增元素</span><br><span class="line">- (void)addobject: (objectType) an0bjectt将传入的参数作为数组的元素添加进去。//注意插入一个NSArray对象时，是将整个数组看作一个整体插入，NSMutableArray的count+1</span><br><span class="line">2.将另外1个数组中的每1个元素添加到可变数组中。</span><br><span class="line">- (void)addobjectsFromArray: (NSArray&lt;0bjectType&gt; *)otherArray;//注意插入一个NSArray对象时，NSMutableArray的count+NSArray对象.count</span><br><span class="line">3.在可变数组中指定的“下标出插入1个元素.</span><br><span class="line">- (void) insert0bject: (0bject Type)an0bject atIndex: (NSUInteger) index;</span><br></pre></td></tr></table></figure>
<h3 id="NSMutableArray的删除注意事项"><a href="#NSMutableArray的删除注意事项" class="headerlink" title="NSMutableArray的删除注意事项"></a>NSMutableArray的删除注意事项</h3><p>来源：<a href="https://www.jianshu.com/p/36fdb18b9687" target="_blank" rel="noopener">iOS小知识(2016.07)—NSMutableArray中删除对象知多少</a></p>
<p>removeObjectAtIndex：删除指定NSMutableArray中指定index的对象，注意index不能越界。【最多只能删除一个对象】</p>
<p>removeObject：删除NSMutableArray中所有isEqual:待删对象的对象可以删除多个对象（只要符合isEqual:的都删除掉）</p>
<p>不要在for in 循环中删除数组内部对象，“易引发崩溃” 大致于C++迭代器失效类似原因。</p>
<p>解决方案：</p>
<p>（1）倒序删除</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (void)removeObjectsReversed</span><br><span class="line">&#123;</span><br><span class="line">    // 可以借鉴这种初始化方法</span><br><span class="line">    NSMutableArray *contents = [@[@&quot;how&quot;, @&quot;to&quot;, @&quot;remove&quot;, @&quot;remove&quot;, @&quot;object&quot;] mutableCopy];</span><br><span class="line">    for (NSInteger i = contents.count - 1; i &gt;= 0; --i) &#123;</span><br><span class="line">        NSString *var = contents[i];</span><br><span class="line">        if ([var isEqualToString:@&quot;remove&quot;]) &#123;</span><br><span class="line">            [contents removeObjectAtIndex:i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;%@&quot;, contents);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//结果:</span><br><span class="line">2016-07-31 21:31:37.655 RemoveObject[5934:325316] (</span><br><span class="line">    how,</span><br><span class="line">    to,</span><br><span class="line">    object</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>（2）先通过indexesOfObjectsPassingTest:把待删除对象的index找出来，再调用removeObjectsAtIndexes:进行一次性删除。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (void)removeObjectsUseEnumration</span><br><span class="line">&#123;</span><br><span class="line">    NSMutableArray *contents = [@[@&quot;how&quot;, @&quot;remove&quot;, @&quot;to&quot;, @&quot;remove&quot;, @&quot;object&quot;] mutableCopy];</span><br><span class="line">    NSIndexSet *indexSet =</span><br><span class="line">        [contents indexesOfObjectsPassingTest:^BOOL(NSString *  _Nonnull var, NSUInteger idx, BOOL * _Nonnull stop) &#123;</span><br><span class="line">            return [var isEqualToString:@&quot;remove&quot;];</span><br><span class="line">        &#125;];</span><br><span class="line">    [contents removeObjectsAtIndexes:indexSet];</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;%@&quot;, indexSet);</span><br><span class="line">    NSLog(@&quot;%@&quot;, contents);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//结果:</span><br><span class="line">2016-07-31 22:10:42.404 RemoveObject[6014:338210] &lt;NSIndexSet: 0x7fb73a516040&gt;[number of indexes: 2 (in 2 ranges), indexes: (1 3)]</span><br><span class="line">2016-07-31 22:10:42.404 RemoveObject[6014:338210] (</span><br><span class="line">    how,</span><br><span class="line">    to,</span><br><span class="line">    object</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h2 id="NSDictionary"><a href="#NSDictionary" class="headerlink" title="NSDictionary"></a>NSDictionary</h2><p>1).这个数组是以键值对的形式存储数据的每往这个数组中存储1个数据,就要求为存储的数据取1个别名.<br>2).别名必须是遵守了<strong>NSCopying协议</strong>的对象。NSString就是遵守 了这个协议的。存储的数据只能是<strong>任意的0C对象</strong>。<br>3).长度固定.NSDictionary数组一旦创建 ,<strong>其长度就固定</strong>，键值对无法新增和删除。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//NSDictionary数组的创建 .</span><br><span class="line">NSDictionary *arr1 = [NSDictionary new] ;</span><br><span class="line">NSDictionary *arr2 = [ [NSDictionary alloc] init];</span><br><span class="line">NSDictionary *arr3 = [NSDictionary dictionary];</span><br><span class="line">创建的数组的元素的个数是0没意义。</span><br><span class="line"></span><br><span class="line">比较常用的一种方法.创建NSDictionary数组的同时指定键值对。//写上值再写键.</span><br><span class="line"></span><br><span class="line">- (instancetype)dictionaryWithobjectsAndKeys:(id)first0bject, ...</span><br><span class="line">  NSDictionary *dict = [NSDictionary dictionaryWithobjectsAndKeys:@&quot;jack&quot; ,@&quot;name&quot; ,@&quot;17&quot; , @&quot;age&quot; ,@&quot;175.5&quot; ,@&quot;height&quot;, nil];</span><br><span class="line">  简要创建的方式。</span><br><span class="line">  NSDictionary *dict = @&#123;键1:值1,键2:值2,键3:值.......&#125;; .</span><br><span class="line">  NSDictionary *dict =@&#123;@&quot;name&quot; :@&quot;jack&quot; ,&quot; age&quot; :@&quot;17&quot; ,@&quot;height&quot; :@&quot;175.5&quot;&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a>常用方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//取值【往字典数组中存储键值对的时候键不允许重复.】</span><br><span class="line">字典数组名[键];这样就可以去到字典数组中这个键对应的值.</span><br><span class="line">NSLog(@&quot;%@&quot; , dict [@&quot;name&quot;]);取出dict字典数组中@&quot;name&quot;这个键对应的值.</span><br><span class="line">-&gt;调用字典数组对象的方法也可以取出键对应的值.</span><br><span class="line">- (nullable ObjectType)objectForKey: (KeyType)aKey;</span><br><span class="line">如果给定的key在数组中不存在取到的值是nil不会报错.</span><br><span class="line">取到字典数组的键值对的个数.</span><br><span class="line">@property (readonly) NSUInteger count;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//遍历</span><br><span class="line">1.使用for in循环。遍历出来的是字典数组中所有的键。再通过键取出对应的值.</span><br><span class="line">NSDictionary *dict = @&#123;</span><br><span class="line">@&quot;name&quot;:@&quot;rose&quot;,</span><br><span class="line">@&quot;age&quot;:@&quot;18&quot;</span><br><span class="line">@&quot;address&quot;:@&quot;BeiJingXXSttreet&quot;</span><br><span class="line">&#125;;</span><br><span class="line">for(id item in dict)&#123;</span><br><span class="line"> 	NSLog(@&quot;%@ = %@&quot; , item, dict [item]);   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2.使用block遍历. </span><br><span class="line">[dict enumerateKeysAndobjectsUsingBlock:^(id _Nonnull key, id _Nonnull obj, BOOL *</span><br><span class="line">_Nonnull stop) &#123;</span><br><span class="line">     NSLog(@&quot;%@ = %&amp;@&quot; , key, obj);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">//持久化</span><br><span class="line">1.将字典数组的信息保存到plist文件中.</span><br><span class="line">- (BOOL)writeToFile: (NSString *)path atomically: (BOOL)useAuxiliaryFile;</span><br><span class="line"></span><br><span class="line">2.从plist文件中还原回字典.</span><br><span class="line">+ (nullable NSDictionary&lt;KeyType, 0bjectType&gt; *)dictionaryWithContentsOfFile: (NSString *)path;</span><br></pre></td></tr></table></figure>
<h3 id="【待补充】引出nonnull-nullable、-Nonnull-Nullable、nonnull-nullable区别-amp-amp-nil、Nil、NULL、NSNull区别-简书-jianshu-com"><a href="#【待补充】引出nonnull-nullable、-Nonnull-Nullable、nonnull-nullable区别-amp-amp-nil、Nil、NULL、NSNull区别-简书-jianshu-com" class="headerlink" title="【待补充】引出nonnull / nullable、_Nonnull / _Nullable、nonnull / nullable区别 &amp;&amp;nil、Nil、NULL、NSNull区别 - 简书 (jianshu.com)"></a>【待补充】引出<a href="https://www.jianshu.com/p/e8869f27fabe" target="_blank" rel="noopener">nonnull / nullable、_Nonnull / _Nullable、<strong>nonnull / </strong>nullable区别 &amp;&amp;nil、Nil、NULL、NSNull区别 - 简书 (jianshu.com)</a></h3><p>block遍历中出现_Nonnull</p>
<h3 id="存储原理"><a href="#存储原理" class="headerlink" title="存储原理"></a>存储原理</h3><p>并不是按照顺序挨个挨个的存储的。存储键值对的时候，会根据键和数组的长度做1个<strong>哈希算法</strong>.算出1个下标。将这个键值对存储在该下标处.【NSArray存储效率更高】<br>取值的时候:也是根据键做1个哈希算法.就可以算出这个键值对存储的下标然后直接找到这个下标的数据取出.</p>
<h3 id="NSMutableDictionary是NSDictionary的子类"><a href="#NSMutableDictionary是NSDictionary的子类" class="headerlink" title="NSMutableDictionary是NSDictionary的子类 ."></a>NSMutableDictionary是NSDictionary的子类 .</h3><p>所以NSMutableDictionary也是1个字典数组,也是以键值对的形式存储数据的.存储在其中的元素可以动态的新增和删除。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1.创建可变字典数组。</span><br><span class="line">NSMutableDictionary *dict1 = [NSMutableDictionary new] ;</span><br><span class="line">NSMutableDictionary *dict2 = [ [NSMutableDictionary alloc] init];</span><br><span class="line">NSMutableDictionary *dict3 = [NSMutableDictionary dictionary];</span><br><span class="line">这样创建出来的可变字典数组的长度为0但是有意义因为可以动态的新增和删除.</span><br><span class="line">NSMutableDictionary *dict = [NSMutableDictionary dictionaryWithobjectsAndKeys:@&quot;jack&quot; ,@&quot;name&quot; ,@&quot;18&quot; ,@&quot;age&quot;, nil];</span><br><span class="line">在创建可变字典数组的同时初始化键值对.</span><br><span class="line">//注意: NSMutableDictionary *dict = @&#123;&#125;;这样是不行的。【原因：指向父类对象】</span><br><span class="line"></span><br><span class="line">2.如何新增键值对。</span><br><span class="line">- (void)set0bject: (ObjectType)an0bject forKey: (KeyType &lt;NSCopying&gt; )aKey;</span><br><span class="line">如果键重复.后添加的就会替换原有的.</span><br><span class="line"></span><br><span class="line">3.如何删除。</span><br><span class="line">- (void) removeAllobjects; 删除所有的键值对。</span><br><span class="line">(void) remove0bjectForKey: (KeyType)aKey;删除指定的键值对。</span><br></pre></td></tr></table></figure>
<h2 id="NSFileManger"><a href="#NSFileManger" class="headerlink" title="NSFileManger"></a>NSFileManger</h2><p>NSFileManger用来操作磁盘上的文件文件央对他们进行创建、 删除、复制拷贝移动…..<br>这个类的对象是以<strong>单例模式</strong>创建的.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//得到NSFileManager的1个单例对象。</span><br><span class="line">NSFileManager *fileManager = [NSFileManager defaultManager] ;</span><br></pre></td></tr></table></figure>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>实现单例模式【1个类的对象,无论在何时创建也无论在什么地方创建也无论创建多少次.创建出来的都是同1个对象.<br>】<br>重写+ allocWithZone:<br>无论如何创建对象,最终都会调用alloc方法来创建对象。<br>1)，alloc方法的内部。 其实什么都没有做，只是调用了allocWithZone:方法。<br>2)，实际上真正申请空间创建对象的事情是allocWithZone:方法在做。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 懒汉模式</span><br><span class="line">+ (instancetype)allocwithZone: (struct. _NSZone *)zone</span><br><span class="line">&#123;</span><br><span class="line">static id instance = nil;</span><br><span class="line">if(instance == nil)</span><br><span class="line">instance = [super allocWithZone:zone];</span><br><span class="line">&#125;</span><br><span class="line">return instance :</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>单例模式的规范:如果类是1个单例模式.要求为类提供1个类方法.来返回这个单例对象。<br>类方法的名称<strong>必须以shared类名; default类名</strong>;</p>
<h3 id="常用方法-3"><a href="#常用方法-3" class="headerlink" title="常用方法"></a>常用方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//判断.</span><br><span class="line">1.判断指定的文件或者文件夹在磁盘.上是否真实的存在</span><br><span class="line">  - (BOOL)fileExistsAtPath: (NSString *)path;</span><br><span class="line">2.判断指定的路径是否真实的存储在我们的磁盘之上,并且判断这个路径是1个文件夹路径还是1个文件路径。</span><br><span class="line">  - (BOOL)fileExistsAtPath: (NSString *)path isDirectory: (B0OL *) isDirectory;</span><br><span class="line">    返回值:代表这个路径是否真实存在.</span><br><span class="line">    参数指针:代表这个路径是否是1个文件夹路径</span><br><span class="line">3.判断指定的文件夹或者文件是否可以读取.</span><br><span class="line">  - (BOOL) isReadableFileAtPath: (NSString *)path;</span><br><span class="line">4.判断指定的文件央或者文件是否可以写入.</span><br><span class="line">  - (BOOL) isWritableFileAtPath: (NSString *) path;</span><br><span class="line">5.判断指定的文件夹或者文件是否可以删除.</span><br><span class="line">  - (BOOL) isDeletableFileAtPath: (NSString *) path</span><br><span class="line">//获取信息.</span><br><span class="line">1.获取指定文件或者文件夹的属性信息.</span><br><span class="line">  - (NSDictionary *)attributes0fItemAtPath: (NSString *) path error:; (NSError **)error</span><br><span class="line">    返回的是1个字典,如果要拿到特定的信息通过key</span><br><span class="line">2.获取指定目录下的所有的文件和目录。是拿到指定目录下的所有的文件和目录所有的后代目录和文件.</span><br><span class="line">  - (NSArray *) subpathsAtPath: (NSString *) path;</span><br><span class="line">  </span><br><span class="line"> ...</span><br></pre></td></tr></table></figure>
<h2 id="CGPoint"><a href="#CGPoint" class="headerlink" title="CGPoint"></a>CGPoint</h2><p>这个结构体一般情况下是用来表示坐标的,用来表示控件在界面上得位置.<br>CGPoint与NSPoint都是同1个结构体，只不过定义两个名字.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//定义</span><br><span class="line">typedef CGPoint NSPoint;</span><br><span class="line">struct CGPoint &#123;</span><br><span class="line">CGFloat X;//CGFloat类型的实际上就是1个double类型的.</span><br><span class="line">CGFloat y;</span><br><span class="line">&#125;;</span><br><span class="line">typedef struct CGPoint CGPoint;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//初始化</span><br><span class="line">CGPoint p1;</span><br><span class="line">p1.x = 20;</span><br><span class="line">p1.y = 30;</span><br><span class="line">2). CGPoint p1 = &#123;20,30&#125;;</span><br><span class="line">3). CGPoint p1 = &#123;.x = 20，.y = 30&#125;;</span><br><span class="line">4). Foundation框架 中提供的函数来快速的创建1个CGPoint变量.</span><br><span class="line">a. CGPointMake(x,y);</span><br><span class="line">CGPoint p1 = CGPointMake(20， 30);</span><br><span class="line">b. NSMakePoint(x,y);</span><br><span class="line">NSPoint p2 = NSMakePoint(20, 30);</span><br></pre></td></tr></table></figure>
<h2 id="CGSize"><a href="#CGSize" class="headerlink" title="CGSize"></a>CGSize</h2><p>声明1个变量来保存某个控件的大小。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//定义</span><br><span class="line">struct CGSize &#123;</span><br><span class="line">CGFloat width;</span><br><span class="line">CGFloat height; </span><br><span class="line">&#125;;</span><br><span class="line">typedef struct CGSize CGSize;</span><br><span class="line">typedef CGSize NSSize;</span><br><span class="line">NSSize和CGSize是同1个结构体，只不过定义了两个名称。</span><br><span class="line">CGSize结构体-般情况下用来表示控件的大小。</span><br><span class="line">    </span><br><span class="line">//-----CGSize声明并初始化的方式- - ------</span><br><span class="line">1). CGSize size;</span><br><span class="line">size.width = 100;</span><br><span class="line">size.height = 30;</span><br><span class="line">2). CGSize size = &#123;100,30&#125;;</span><br><span class="line">3).CGSize size = &#123;.width = 100，.height = 30&#125;;</span><br><span class="line">4).Foundation框架中提供了函数用来快速的得到1个CGSize结构体变量.</span><br><span class="line">a. CGSizeMake (width,height);</span><br><span class="line">CGSize size0 = CGSizeMake(100， 30);</span><br><span class="line">b. NSMakeSize(w,h);</span><br><span class="line">CGSize size1 = NSMakeSize(100， 30);</span><br></pre></td></tr></table></figure>
<h2 id="CGRect"><a href="#CGRect" class="headerlink" title="CGRect"></a>CGRect</h2><p>这个结构体变量一般情况下存储1个控件的位置和大小。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//定义</span><br><span class="line">struct CGRect &#123;</span><br><span class="line">CGPoint origin;</span><br><span class="line">CGSize size;</span><br><span class="line">&#125;;</span><br><span class="line">typedef struct CGRect CGRect;</span><br><span class="line">typedef CGRect NSRect;</span><br><span class="line">NSRect和CGRect是一样的。</span><br><span class="line">    </span><br><span class="line">//---CGRecr的声明和初始化</span><br><span class="line">1).CGRect rect;</span><br><span class="line">rect.origin.x = 20;</span><br><span class="line">rect.origin.y = 40;</span><br><span class="line">rect. size.width = 100;</span><br><span class="line">rect. size. height = 30;</span><br><span class="line">//注意 当结构体作为另外1个结构体或者对象的1个属性的时候,不能直接&#123;&#125;赋值.</span><br><span class="line">CGRect rect;</span><br><span class="line">rect.origin = (CGPoint)&#123;10,20&#125;;</span><br><span class="line">rect.size = (CGSize)&#123;100,30&#125;;</span><br><span class="line"></span><br><span class="line">2).也提供了函数来快速的创建GRect变量. </span><br><span class="line">CGRect rect = CGRectMake(10, 20,100, 30);</span><br><span class="line">CGRect rect1 =NSMakeRect (10,20,100,30);</span><br></pre></td></tr></table></figure>
<h2 id="NSNumber"><a href="#NSNumber" class="headerlink" title="NSNumber"></a>NSNumber</h2><p>是Foundation框架中定义好的1个类.这个类的对象的作用就是用来<strong>包装基本数据类型</strong>的。<br>将基本数据类型存储到NSArray数组中的步骤：1.先将基本数据类型包装到NSNumber对象中.<br>2.再将NSNumber对象存储到NSArray数组中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">NSNumber *number1 = [NSNumber numberWithFloat:10.1f];</span><br><span class="line">NSNumber *number2 = [NSNumber numberwithFloat:10.2f];</span><br><span class="line">NSNumber *number3出(NSNumber numberWithFloat:10.3f];</span><br><span class="line">NSArray *arr = @[number1, number2, number3];</span><br><span class="line">for (NSNumber *num in arr)&#123;</span><br><span class="line">  NSLog(@&quot;%f&quot; , num. floatValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">创建NSNumber对象的简写方式:</span><br><span class="line">@10;//代表是1个NSNumber对象,这个对象中包装的是整形的10 等于 [NSNumber numberWithInt:10];</span><br><span class="line">包装注意:</span><br><span class="line">如果后面的数据是1个变量那么这个变量就必须要使用小括弧括起来。</span><br><span class="line">@(num):</span><br></pre></td></tr></table></figure>
<h2 id="NSValue"><a href="#NSValue" class="headerlink" title="NSValue"></a>NSValue</h2><p>NSValue类的对象就是用来<strong>包装结构体变量</strong>【NSRange、CGPoint、CGSize、CGRect，该变量是无法存储到集合之中.】的。<br>解决方案:<br>先将这写结构体变量存储到0C对象中,再将0C对象存储到集合之中.</p>
<p>注意：NSValue存储不可变OC对象， 如果存入结构体，仅能只读；或者存入结构体的地址，利用二级指针来分配结构体内存并初始化【手动分配、释放内存】。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CGPoint p1 = CGPointMake(10, 20);</span><br><span class="line">CGPoint p2 =CGPointMake(110, 120);</span><br><span class="line">CGPoint p3 =CGPointMake(110, 320);</span><br><span class="line">CGPoint p4 =CGPointMake(110, 240);</span><br><span class="line">NSValue *v1 = [NSValue valueWithPoint:p1];</span><br><span class="line">NSValue *v2 = [NSVa lue va lueWithPoint:p2] ;</span><br><span class="line">NSValue *v3 = [NSValue valueWithPoint:p3];</span><br><span class="line">NSValue *V4 = [NSValue va LueWithPoint:p4] ;</span><br><span class="line">NSArray *arr = @[v1,v2,v3,v4];</span><br><span class="line">for(NSValue *V in arr)</span><br><span class="line">&#123;</span><br><span class="line">   NSLog(@&quot;%s@&quot; ,NSStringF romPoint(v.pointValue));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="NSDate"><a href="#NSDate" class="headerlink" title="NSDate"></a>NSDate</h2><p>NSDate取到的时间是当前系统的格林威治时间,0时区的时间.<br>NSDateFormatter转换成字符串以后会转换为当前系统的时区的时间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">NSDate *date = [NSDate date] ;</span><br><span class="line">NSLog(@&quot;*@&quot; , date);</span><br><span class="line">2).格式化输出日期。指定日期输出的格式</span><br><span class="line">默认的格式年-月-日时:分:秒+时区.</span><br><span class="line">NSDate *date = NSDate date];</span><br><span class="line">NSLog(@&quot;%@&quot; , date) ;</span><br><span class="line">//1.先要创建1个NSDateFormatter对象,这个对象作用:将1个日期转换成1个指定的格式.</span><br><span class="line">NSDateFormatter *formatter = [ [NSDateFormatter alloc] init];</span><br><span class="line">//2.告诉这个日期格式化器对象要把日期转换个什么样子的.</span><br><span class="line">yyyy:年份</span><br><span class="line">MM:月份.</span><br><span class="line">mm:分钟。</span><br><span class="line">dd:天.</span><br><span class="line">hh: 12小时.</span><br><span class="line">HH: 24小时</span><br><span class="line">ss:秒</span><br><span class="line">formatter.dateFormat = *&quot;yyy年MM月dd日 HH点mm分ss秒&quot;;</span><br><span class="line">//3.使用日期格式化器将指定的日期转换指定格式的字符串.</span><br><span class="line">NSString *str =[formatter str ingF romDate:date] ;</span><br><span class="line">NSLog(@&quot;str = %@&quot; ,str);</span><br><span class="line">-(NSString *)stringFromDate: (NSDate *)date; //将 日期类型换换为字符串</span><br><span class="line">-(NSDate *)dateF romString: (NSString *)string;//将字符串转换为日期对象。</span><br><span class="line"></span><br><span class="line">//计算时间</span><br><span class="line">1.想得到明天此时此刻的时间。</span><br><span class="line">当前时间的基础之，上+ 1天的时间。</span><br><span class="line">在当前时间的基础之上,新增指定的时间.得到的1个新的时间。</span><br><span class="line">+ (instancetype) dateWithTimeIntervalSinceNow: (NST imeInterval)secs ;</span><br><span class="line">在当前的时间的基础之上，新增指定的秒。后的时间</span><br><span class="line">得到东八区的时间:</span><br><span class="line">NSDate *d1 = [NSDate dateWithTimeIntervalSinceNow: 8*60*60];</span><br><span class="line">传入1个负数就是在当前时间的基础之，上减指定的秒数.</span><br><span class="line">2.求两个时间之间的差。</span><br><span class="line">可以实现的效果。 就是可以计算出执行代码所花费的时间。</span><br><span class="line">- (NSTimeInterval)t imeIntervalSinceDate: (NSDate *) anotherDate;</span><br><span class="line"></span><br><span class="line">//得到NSDate中的年 月日时分秒。</span><br><span class="line">1.得到时间的各个部分。可以使用日期格式化器来得到.</span><br><span class="line">NSDate *date = [NSDate date] ;</span><br><span class="line">NSDateFormatter *formatter = [NSDateFormatter new] ;</span><br><span class="line">formatter. dateFormat = @&quot;HH&quot; ;</span><br><span class="line">NSString *str = [formatter stringF romDate:datel;</span><br><span class="line">int year = str. intValue; </span><br><span class="line">NSLog(@&quot;year = %d&quot; ,year);</span><br><span class="line"></span><br><span class="line">2.日历对象。</span><br><span class="line">NSDate *date = [NSDate date] ;</span><br><span class="line">//1.创建1个日历对象。调用类方法currentCalendar得到1个日 历对象.</span><br><span class="line">NSCalendar *calendar = [NSCaLendar currentCalendar] ;</span><br><span class="line">//2.指定日历对象取到日期的对象的那些部分。是要取那1个时间对象的部分.</span><br><span class="line">//返回1个日期组件对象.这个对象中就有指定日期的指定部分，</span><br><span class="line">NSDateComponents *com = [caLendar components:NSCalendarUnitYear|NSCalendarUnitMonth |NSCalendarUnitDay fromDate: date];</span><br><span class="line">NSLog(@&quot;%ld-%ld- %1d&quot;,com.year,com.month,com.day,com.weekday); // weekday 周日为1，周六为7</span><br></pre></td></tr></table></figure>
<h1 id="【待补充】懒加载"><a href="#【待补充】懒加载" class="headerlink" title="【待补充】懒加载"></a>【待补充】懒加载</h1><p><a href="https://blog.csdn.net/weixin_34161032/article/details/91633027?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_antiscanv2&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_antiscanv2&amp;utm_relevant_index=2" target="_blank" rel="noopener">swift懒加载（lazy load）VS OC懒加载</a></p>
<h1 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h1><h2 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arc4random()%x+y ：意思是随机生成y到y＋x之间的随机整数。不包括（y＋x）</span><br></pre></td></tr></table></figure>
<h1 id="BUG"><a href="#BUG" class="headerlink" title="BUG"></a>BUG</h1><h2 id="Type-name-does-not-allow-storage-class-to-be-specified"><a href="#Type-name-does-not-allow-storage-class-to-be-specified" class="headerlink" title="Type name does not allow storage class to be specified"></a>Type name does not allow storage class to be specified</h2><p>在oc中，static不能修饰实例变量【即类属性/类方法】</p>
<p>只能这样用：</p>
<p> 1，在.h中定义，在导入该.h的.m中使用</p>
<p>2, 在.m中定义使用，可以在方法里定义使用（使局部变量保留多次调用一个方法所得的值）</p>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="属性命名的规范"><a href="#属性命名的规范" class="headerlink" title="属性命名的规范"></a>属性命名的规范</h2><p>声明属性时，命名前面下划线，而对应set/get方法名为set/get+去掉下划线的属性名首字母大写。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eg: NSString * _name; </span><br><span class="line">setName:NSString * name;</span><br></pre></td></tr></table></figure>
<h2 id="类方法的规范"><a href="#类方法的规范" class="headerlink" title="类方法的规范"></a>类方法的规范</h2><p>提供与自定义构造方法相同功能的类方法【用来让外界调用类方法来快速的得到1个对象】，且由该类方法构建的对象在方法中就已经被autorelease【该对象就会被自动的加入到自动释放池】。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//对应实例方法 -(instancetype)init;</span><br><span class="line">//autorelease 在ARC模式下不要写</span><br><span class="line">+(instancetype)person   </span><br><span class="line">&#123;</span><br><span class="line">   return [[[self alloc] init] autorelease];</span><br><span class="line">&#125;</span><br><span class="line">//带参构造对象的类方法</span><br><span class="line">//对应实例方法 -(instancetype)initWithName:(NSString *)name andAge:(int)age andWeight:(float)weight;</span><br><span class="line">+(instancetype)personWithName:(NSString *)name andAge:(int)age andWeight:(float)weight</span><br><span class="line">&#123;</span><br><span class="line">   return [[[self alloc] initWithName:name andAge:age andWeight:weight] autorelease];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="项目ARC模式与MRC模式兼容"><a href="#项目ARC模式与MRC模式兼容" class="headerlink" title="项目ARC模式与MRC模式兼容"></a>项目ARC模式与MRC模式兼容</h2><p><strong>ARC模式项目中部分文件使用MRC模式</strong></p>
<p>TARGETS-&gt;Build Phases -&gt; Compile Sources -&gt;选择指定文件 补充命令 <code>-fno-objc-arc</code></p>
<p><strong>整个项目MRC模式转换为ARC模式（新手别碰）</strong></p>
<p>Edit-&gt;Convert-&gt;To Objective-C ARC 【过程不可逆，需备份】</p>
<h2 id="VMware16安装macOS12手把手教程"><a href="#VMware16安装macOS12手把手教程" class="headerlink" title="VMware16安装macOS12手把手教程"></a><a href="https://www.bilibili.com/read/cv16108208" target="_blank" rel="noopener">VMware16安装macOS12手把手教程</a></h2>
      
    </div>
    
    
    

    <div>
    
        
<div style="text-align:center;color: #ccc;font-size:14px;">----------------  本文结束  ----------------</div>
<br>
<div class="my_post_copyright">
  <script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>
  
  <!-- JS库 sweetalert 可修改路径 -->
  <script type="text/javascript" src="http://jslibs.wuxubj.cn/sweetalert_mini/jquery-1.7.1.min.js"></script>
  <script src="http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.min.js"></script>
  <link rel="stylesheet" type="text/css" href="http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.mini.css">

  <p><span>本文标题:</span>Objective-C语法点</p>
  <p><span>文章作者:</span>Pabebe</p>
  <p><span>发布时间:</span>2021年11月10日 - 17:10:18</p>
  <p><span>最后更新:</span>2022年05月02日 - 10:45:22</p>
  <p><span>原始链接:</span><a href="/article/d97699bf/" title="Objective-C语法点">https://pabebezz.github.io/article/d97699bf/</a>
    <span class="copy-path" title="点击复制文章链接"><i class="fa fa-clipboard" data-clipboard-text="https://pabebezz.github.io/article/d97699bf/" aria-label="复制成功！"></i></span>
  </p>
  <p><span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">署名-非商业性使用-禁止演绎 4.0 国际</a> 转载请保留原文链接及作者。</p>  
</div>
<script> 
    var clipboard = new Clipboard('.fa-clipboard');
    clipboard.on('success', $(function(){
      $(".fa-clipboard").click(function(){
        swal({   
          title: "",   
          text: '复制成功',   
          html: false,
          timer: 500,   
          showConfirmButton: false
        });
      });
    }));  
</script>


    
</div>


    

    

    
    
   <!-- 添加版权声明 -->
    <div>
    
        
     
    </div>

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/article/d9b803c4/" rel="next" title="排查网络故障">
                <i class="fa fa-chevron-left"></i> 排查网络故障
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/article/f6fbec83/" rel="prev" title="安全设置手段">
                安全设置手段 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Pabebe">
            
              <p class="site-author-name" itemprop="name">Pabebe</p>
              <p class="site-description motion-element" itemprop="description">I have the soulful eyes of a cow</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">92</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">20</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/Pabebezz" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://blog.csdn.net/Pabebe" target="_blank" title="CSDN">
                      
                        <i class="fa fa-fw fa-globe"></i>CSDN</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:zezuwang@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://example.com/" title="Title" target="_blank">Title</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#OC特点"><span class="nav-number">1.</span> <span class="nav-text">OC特点</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#【待补充】实例对象、类对象（class-object）与元类对象-metaclass-object"><span class="nav-number">1.1.</span> <span class="nav-text">【待补充】实例对象、类对象（class object）与元类对象(metaclass object)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#【待补充】消息机制"><span class="nav-number">2.</span> <span class="nav-text">【待补充】消息机制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#总结取到类在代码段中的地址的方式．"><span class="nav-number">2.1.</span> <span class="nav-text">总结取到类在代码段中的地址的方式．</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类与方法在代码段中的存储方式与调用机制"><span class="nav-number">2.2.</span> <span class="nav-text">类与方法在代码段中的存储方式与调用机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#点语法"><span class="nav-number">2.3.</span> <span class="nav-text">点语法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NSLog与printf的区别"><span class="nav-number">2.4.</span> <span class="nav-text">NSLog与printf的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NSObject和id的异同"><span class="nav-number">2.5.</span> <span class="nav-text">NSObject和id的异同</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#id和instancetype的区别-泛型类型"><span class="nav-number">2.6.</span> <span class="nav-text">id和instancetype的区别(泛型类型)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#＠class（类前置声明）与＃import的区别"><span class="nav-number">2.7.</span> <span class="nav-text">＠class（类前置声明）与＃import的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#OC支持参数个数不同的函数重载"><span class="nav-number">2.8.</span> <span class="nav-text">OC支持参数个数不同的函数重载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#struct与class的区别"><span class="nav-number">2.9.</span> <span class="nav-text">struct与class的区别</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#属性"><span class="nav-number">3.</span> <span class="nav-text">属性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#合成存取器【属性是为成员变量服务的】"><span class="nav-number">3.1.</span> <span class="nav-text">合成存取器【属性是为成员变量服务的】</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#常用修饰词"><span class="nav-number">3.2.</span> <span class="nav-text">常用修饰词</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#属性类型相关"><span class="nav-number">3.2.1.</span> <span class="nav-text">属性类型相关</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程相关"><span class="nav-number">3.2.2.</span> <span class="nav-text">线程相关</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#访问权限相关"><span class="nav-number">3.2.3.</span> <span class="nav-text">访问权限相关</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法生成相关"><span class="nav-number">3.2.4.</span> <span class="nav-text">方法生成相关</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#类的扩展"><span class="nav-number">4.</span> <span class="nav-text">类的扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#分类"><span class="nav-number">4.1.</span> <span class="nav-text">分类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#延展"><span class="nav-number">4.2.</span> <span class="nav-text">延展</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#真私有属性"><span class="nav-number">4.2.1.</span> <span class="nav-text">真私有属性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#延展和分类的区别"><span class="nav-number">4.3.</span> <span class="nav-text">延展和分类的区别</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#block"><span class="nav-number">5.</span> <span class="nav-text">block</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#block简写规则"><span class="nav-number">5.1.</span> <span class="nav-text">block简写规则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#block访问外部变量"><span class="nav-number">5.2.</span> <span class="nav-text">block访问外部变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#block与函数的区别"><span class="nav-number">5.3.</span> <span class="nav-text">block与函数的区别</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#协议protocol"><span class="nav-number">6.</span> <span class="nav-text">协议protocol</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#类是单继承，可以多协议"><span class="nav-number">6.1.</span> <span class="nav-text">类是单继承，可以多协议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#协议与协议之间可以相互继承"><span class="nav-number">6.2.</span> <span class="nav-text">协议与协议之间可以相互继承</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#协议类型限制指针"><span class="nav-number">6.3.</span> <span class="nav-text">协议类型限制指针</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#检查"><span class="nav-number">7.</span> <span class="nav-text">检查</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#内存管理"><span class="nav-number">8.</span> <span class="nav-text">内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#引用计数"><span class="nav-number">8.1.</span> <span class="nav-text">引用计数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#僵尸对象"><span class="nav-number">8.2.</span> <span class="nav-text">僵尸对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#野指针"><span class="nav-number">8.3.</span> <span class="nav-text">野指针</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#衍生出：objc中向一个nil对象发送消息将会发生什么？"><span class="nav-number">8.3.1.</span> <span class="nav-text">衍生出：objc中向一个nil对象发送消息将会发生什么？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#autoreleasepool-自动释放池"><span class="nav-number">8.4.</span> <span class="nav-text">autoreleasepool (自动释放池)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ARC机制"><span class="nav-number">8.5.</span> <span class="nav-text">ARC机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#强指针与弱指针"><span class="nav-number">8.5.1.</span> <span class="nav-text">强指针与弱指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#property-禁用retain"><span class="nav-number">8.5.2.</span> <span class="nav-text">@property 禁用retain</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#禁用"><span class="nav-number">8.5.3.</span> <span class="nav-text">禁用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ARC机制-与-垃圾回收机制GC的区别"><span class="nav-number">8.5.4.</span> <span class="nav-text">ARC机制 与 垃圾回收机制GC的区别</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#【待补充】动态特性"><span class="nav-number">9.</span> <span class="nav-text">【待补充】动态特性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#动态类型"><span class="nav-number">9.1.</span> <span class="nav-text">动态类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#动态绑定"><span class="nav-number">9.2.</span> <span class="nav-text">动态绑定</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#动态加载"><span class="nav-number">9.3.</span> <span class="nav-text">动态加载</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数据结构"><span class="nav-number">10.</span> <span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#NSString"><span class="nav-number">10.1.</span> <span class="nav-text">NSString</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#注意点"><span class="nav-number">10.1.1.</span> <span class="nav-text">注意点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#深拷贝与浅拷贝"><span class="nav-number">10.1.2.</span> <span class="nav-text">深拷贝与浅拷贝</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常用方法"><span class="nav-number">10.1.3.</span> <span class="nav-text">常用方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NSMutableString是NSString的子类"><span class="nav-number">10.1.4.</span> <span class="nav-text">NSMutableString是NSString的子类.</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#集合"><span class="nav-number">10.2.</span> <span class="nav-text">集合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NSArray"><span class="nav-number">10.3.</span> <span class="nav-text">NSArray</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#常用方法-1"><span class="nav-number">10.3.1.</span> <span class="nav-text">常用方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NSMutableArray是NSArray的子类"><span class="nav-number">10.3.2.</span> <span class="nav-text">NSMutableArray是NSArray的子类.</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NSMutableArray的删除注意事项"><span class="nav-number">10.3.3.</span> <span class="nav-text">NSMutableArray的删除注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NSDictionary"><span class="nav-number">10.4.</span> <span class="nav-text">NSDictionary</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#常用方法-2"><span class="nav-number">10.4.1.</span> <span class="nav-text">常用方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#【待补充】引出nonnull-nullable、-Nonnull-Nullable、nonnull-nullable区别-amp-amp-nil、Nil、NULL、NSNull区别-简书-jianshu-com"><span class="nav-number">10.4.2.</span> <span class="nav-text">【待补充】引出nonnull / nullable、_Nonnull / _Nullable、nonnull / nullable区别 &amp;&amp;nil、Nil、NULL、NSNull区别 - 简书 (jianshu.com)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#存储原理"><span class="nav-number">10.4.3.</span> <span class="nav-text">存储原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NSMutableDictionary是NSDictionary的子类"><span class="nav-number">10.4.4.</span> <span class="nav-text">NSMutableDictionary是NSDictionary的子类 .</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NSFileManger"><span class="nav-number">10.5.</span> <span class="nav-text">NSFileManger</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#单例模式"><span class="nav-number">10.5.1.</span> <span class="nav-text">单例模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常用方法-3"><span class="nav-number">10.5.2.</span> <span class="nav-text">常用方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CGPoint"><span class="nav-number">10.6.</span> <span class="nav-text">CGPoint</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CGSize"><span class="nav-number">10.7.</span> <span class="nav-text">CGSize</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CGRect"><span class="nav-number">10.8.</span> <span class="nav-text">CGRect</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NSNumber"><span class="nav-number">10.9.</span> <span class="nav-text">NSNumber</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NSValue"><span class="nav-number">10.10.</span> <span class="nav-text">NSValue</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NSDate"><span class="nav-number">10.11.</span> <span class="nav-text">NSDate</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#【待补充】懒加载"><span class="nav-number">11.</span> <span class="nav-text">【待补充】懒加载</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#常用函数"><span class="nav-number">12.</span> <span class="nav-text">常用函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#随机数"><span class="nav-number">12.1.</span> <span class="nav-text">随机数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#BUG"><span class="nav-number">13.</span> <span class="nav-text">BUG</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Type-name-does-not-allow-storage-class-to-be-specified"><span class="nav-number">13.1.</span> <span class="nav-text">Type name does not allow storage class to be specified</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#补充"><span class="nav-number">14.</span> <span class="nav-text">补充</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#属性命名的规范"><span class="nav-number">14.1.</span> <span class="nav-text">属性命名的规范</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类方法的规范"><span class="nav-number">14.2.</span> <span class="nav-text">类方法的规范</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#项目ARC模式与MRC模式兼容"><span class="nav-number">14.3.</span> <span class="nav-text">项目ARC模式与MRC模式兼容</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#VMware16安装macOS12手把手教程"><span class="nav-number">14.4.</span> <span class="nav-text">VMware16安装macOS12手把手教程</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Pabebe</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">本站总字数&#58;</span>
    
    <span title="本站总字数">215.1k</span> 

    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-heart"></i>
    </span>
    <span id="busuanzi_container_site_pv" style="display:none">
    总访问量 <span id="busuanzi_value_site_pv"></span> 次
    <span class="post-meta-divider">|</span>
    </span>
    <span class="post-meta-item-icon">
      <i class="fa fa-user-md"></i>
    </span>
    <span id="busuanzi_container_site_uv" style="display:none">
    有<span id="busuanzi_value_site_uv"></span>人到访
    </span>

  
</div>

<div>

</div>

<!--  
  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div> 



   <span class="post-meta-divider">|</span>
 

 
 <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div> 
 -->




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>

<!-- 页面点击出现文字 -->
 <script type="text/javascript" src="/js/src/myLittleWits.js"></script>
 
</html>
